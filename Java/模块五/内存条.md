1.内存：可以理解为“内存条”，所有的软件，程序运行起来都会进入到内存中，占用内存，在java当中，将内存划分了五块
	哪五块？
		a.栈（Stack）
			主要运行方法，方法的运行都会进栈内存运行，运行完毕后，需要“弹栈”，为了弹空间
		b.堆（Heap）
			保存的是对象，数组，每new一次，都会在堆内存中开辟空间，，并为这个空间分配一个地址值，堆内存中的数据都是有默认值的
				整数：0
				小数：0.0
				字符：'\u0000'
				布尔：false
				引用：null
		c.方法区(Meth Area)
			代码的"预备区",记录了类的信息以及方法的信息
			方法中主要保存了class文件及其其中的信息
			代码运行之前,需要先进行内存(方法区)
		d.本地方法栈(Native Method Stack):专门运行native(本地方法)
			本地方法可以理解为堆对Java功能的补充
				有很多功能,Java语言实现不了,所以就需要依靠本地方法完成(c语言编写)
		e.寄存器(pc register) ->和cpu有关

java==**底层运行类时的机制**==
		==第一步==从类代码的创建到(javac)编译过程后,将源码成字节码并写入.class文件
			这个过程发生在图表的​**​最左边​**​，将 `.java`源代码文件转换为 `.class`字节码文件。
	​**​具体步骤包括：​**​
1. ​**​词法分析​**​：
    - `javac`读取你的 `Test.java`源代码，将其中的字符流（如 `p`,`u`,`b`,`l`,`i`,`c`）转换成一个个有意义的​**​标记​**​（`token`），例如 `public`、`class`、`Test`、`{`、`int`、`[`、`]`等。这就像是把一句话拆分成一个个独立的单词。
2. ​**​语法分析​**​：
    - 编译器检查这些标记的排列顺序是否符合Java的语法规则。例如，它检查 `public class Test`后面是否跟着 `{`，`int[] arr`后面是否跟着 `=`等。如果不符合（比如你写成了 `int[ arr]`），就会抛出我们常见的​**​编译错误​**​（Compilation Error），例如 `';' expected`。
3. ​**​语义分析​**​：
    - 编译器进行更深层次的检查，确保代码的​**​逻辑是合理的​**​。例如，检查变量是否在使用前已被声明、数据类型是否匹配（比如你不会把一个字符串赋值给一个整型变量）等。
4. ​**​生成字节码​**​：
    - 在经过以上所有检查后，`javac`​**​最关键的工作​**​就是将符合规范的源代码翻译成​**​字节码​**​，并写入 `Test.class`文件。字节码是一种与特定机器指令无关的、专为JVM设计的中间代码。它是Java实现“一次编写，到处运行”的基石。
​**​小结：`javac`是一个“翻译官”，它把人类可读的Java源代码，严格检查后翻译成JVM可读的 `.class`字节码文件。这个过程是​**​离线​**​的，发生在程序运行之前。​**
		==第二步== 将class文件加载到内存（这个过程发生在图表中的​**​中间部分​**​，当你在命令行输入 `java Test`来运行程序时，Java虚拟机（JVM）开始工作)
			类
			==加载==(找到class文件并将其二进制数据读入内存,再然后在​**​方法区​**​中为这个类创建一个 `java.lang.Class`对象，作为该类的各种数据（如类名、父类、方法、变量等元信息）的访问入口。图中“方法区”里放的 `public class Test{...}`就是这些元信息),
			==链接==
				三步
					验证
						(确保加载的字节码是合法、安全的，不会损害JVM自身。这是一道重要的安全防线)
					准备
						为类的​**​静态变量​**​在方法区中分配内存并设置默认初始值（如 `static int a`会被初始化为 `0`）
					​**​解析​**​：将符号引用转换为直接引用。这个过程可以简单理解为将代码中提到的其他类、方法、字段的名称，转换成具体的内存地址
			==初始化==
				执行类的​**​静态变量赋值​**​和​**​静态代码块​**​。例如，如果有 `static int a = 5;`，在准备阶段 `a`是 `0`，到了初始化阶段才会被赋值为 `5`
			**​只有当类的加载、链接、初始化都完成后，这个类才算是真正准备好可以被使用了。​**​ 之后，JVM就会去执行这个类的 `main`方法，`main`方法被压入​**​Java栈​**​，开始创建对象（如 `new int[3]`），对象实例存储在​**​堆​**​中，从而完成了图中展示的整个流程。

​**​小结：类加载是JVM将字节码文件装入内存、并为其做好运行前准备的过程。这个过程是​**​在线​**​的，发生在程序运行之时(前)**
		在运行程序（即开始执行 `main`方法中的代码）​**​之前​**​，JVM 会“在线”地、==按需地完成==这个特定类（包含 `main`方法的类）的​**​加载、链接和初始化​**​。
这个过程可以更精确地描述为：
1. ​**​触发​**​：当你在命令行输入 `java [ClassName]`（例如 `java Test`）时，JVM 被启动。它的首要任务就是找到并加载你指定的这个主类。
2. ​**​执行顺序​**​：JVM 会为主类 `Test`完整地执行​**​加载 -> 链接（验证、准备、解析）-> 初始化​**​这一系列步骤。只有当这些步骤都成功完成后，`Test`类才被认为是“已准备好”的。
3. ​**​寻找 `main`方法​**​：在初始化阶段结束后，JVM 才会开始在这个已经准备好的 `Test`类中寻找并执行 `public static void main(String[] args)`方法。
所以，图中的 `将class文件加载到内存（方法区）`这一步，就是这个完整类加载过程的一个概括性表示。​**​`main`方法的第一行代码能够开始执行，其前提正是它所在的类已经被 JVM 加载、链接并初始化完毕。​**​
​**​一个重要的补充：​**​
“按需加载”是 JVM 的工作原则。这意味着：
- ​**​首先​**​，JVM 只会先加载、链接、初始化包含 `main`方法的那个入口类
- ​**​然后​**​，在 `main`方法执行过程中，如果遇到了​**​新的、尚未加载的类​**​（例如，你 `new`了一个 `String`对象，或者调用了另一个类的方法），JVM 才会再次触发对这个新类的​**​加载 -> 链接 -> 初始化​**​过程。
这个过程在图中也有体现：在 `main`方法中执行 `new int[3]`时，JVM 才会在​**​堆​**​中为数组对象分配内存。
		![[java内存管理机制.png]]
一个数组的内存图
	![[Pasted image 20250913222921.png]]
两个数组的内存图
	![[Pasted image 20250913223129.png]]
	![[Pasted image 20250913223145.png]]
两个数组指向同一片空间内存图
![[Pasted image 20250913223501.png]]
![[Pasted image 20250913223441.png]]
