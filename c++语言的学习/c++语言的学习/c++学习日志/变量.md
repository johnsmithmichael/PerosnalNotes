# c++中的数据类型分为基本数据类型和自定义数据类型
	1基本数据类型 这些是语言内置的，不需要包含任何头文件或使用标准库就可以直接使用（例如string就要包含头文件）
	整数类型:int,char，short,long，long long,及其unsigned版本
	浮点类型​​：`float`, `double`, `long double`
	​​布尔类型​​：`bool`
	空类型​​：`void`
	`char` 类型的大小通常为 ​**​1 字节​**​（具体由编译器实现决定），但它被设计为表示字符，而非专门用于处理原始字节。
特殊的如：std:byte的引入（c++17）
		为了明确表示内存中的原始字节（例如处理二进制数据或硬件操作），C++17 在标准库中定义了 ​**​`std::byte`​**​，它位于 `<cstddef>` 头文件中
#### 定义与本质
**底层实现​**​：`std::byte` 是一个 ​**​枚举类​**​（`enum class`），其底层类型为 `unsigned char`
**设计目的​**​：提供类型安全的字节操作，避免与字符类型（如 `char`）混淆
![[byte类型的定义.png]]
核心特性：
	​**​大小保证​**​：`sizeof(std::byte) == 1`，即始终占用 1 字节
	**操作限制**：**不支持算术运算​**​（如 `+`, `-`），因为字节本身没有数值语义
			支持位运算​**​（如 `|`, `&`, `~`, `<<`, `>>`），因为字节操作通常涉及位掩码或移位
			必须通过 `std::to_integer<T>()` 转换为整数类型后才能进行算术操作
	![[byte与char与unsigned char的类型比较.png]]
	![[byte的基本使用.png]]
	![[位运算操作.png]]
	![[转换为整数.png]]
	

			
			
	### 注意事项
1. ​**​头文件依赖​**​：使用 `std::byte` 必须包含 `<cstddef>`。
2. ​**​类型转换​**​：禁止隐式转换为其他类型，必须显式调用 `std::to_integer<T>()`。
3. ​**​兼容性​**​：C++17 及以上版本支持，旧版本需使用 `unsigned char` 替代。
	### 总结

- ​**​`std::byte` 不是基本数据类型​**​，而是标准库提供的类型，专门用于处理原始字节。
- 它通过类型安全和操作限制，避免了传统 `char` 类型的语义模糊问题。
- 在需要明确表示二进制数据（如网络协议解析、硬件寄存器操作）时，优先使用 `std::byte`；在涉及字符或小整数时，仍使用 `char` 或 `unsigned char`。
![[c++中不同前缀表示不同进制的字面量.png]]
# 细节：
	1.double和float的区别：
		float存储大小与精度
			float  4字节  有效数字位数6-7位  数值范围±1.2×10⁻³⁸ 到 ±3.4×10³⁸  
			double  8字节  有效数字位数15-16位  数值范围±2.3×10⁻³⁰⁸ 到 ±1.7×10³⁰⁸
	​精度差异​​：`double` 的精度是 `float` 的约两倍
			例如:float f =0.1f //实际存储值如（0.100000001）
				double d=0.1 //存储接近真实值（0.10000000000000001）
				默认为double
	性能与内存占比：

![[double与float的内存占用对比.png]]

float要注意隐式类型转换如float f=1.0f;//将double隐式转换为float，可能导致精度丢失，要显示声明float f = 1.0f;
浮点数避免直接比较如 if( a== b)//错误方式，正确方式是比较差值范围是否在容差范围内如：if（std::abs(a-b)<1e-6）{...}


## String字符串：
	1.不是基本数据类型，是标准模板库（STL）中的一个类，属于标准库的一部分。需要包含头文件，并且位于std命名空间中
	2.字符串在c++中的实现：
		c风格字符串：​**​本质​**​：字符数组（以 `\0` 结尾的 `char` 数组），例如
			char str[] = "Hello";  // 实际存储为 {'H', 'e', 'l', 'l', 'o', '\0'}
		特点：属于复合数据类型（由基本类型char组成的数组）
			操作需依赖函数如（strlen，strcpy），易出错且不安全
	2.std:string类，本质是标准库提供的类（定义在<string>头文件中）
		例如
			#include <string>
			std::string s = "Hello";  // 动态管理内存的字符串对象
		特点：属于标准库类型非基本数据类型，提供丰富的操作方法（如append（），find（）），安全且高效
	3.为什么说字符串不是基本数据类型？
1. **动态内存管理​**​  
    `std::string` 内部动态分配内存以支持可变长度字符串，而基本数据类型的大小固定。
2. ​**​面向对象特性​**​  
    `std::string` 是一个类，封装了数据（字符序列）和操作（如拼接、比较），而基本类型不包含方法。
3. ​**​依赖标准库​**​  
    使用 `std::string` 需要包含 `<string>` 头文件并依赖标准库实现，而基本数据类型是语言核心的一部分。
对比int，int a=10;int b=a+20；
而std:string是，#include<string>
			std::string s1="hello"
			std::string s2=s1+"world";通过重载的'+'操作符拼接
	4.常见误区：​**​字符串字面量​**​
				- `"Hello"` 是常量字符数组（类型为 `const char[6]`），可隐式转换为 `std::string`，但本身不是基本类型。
				- 例如auto推导 auto s="hello";//s的类型是const char*（常量内容的指针），而非'std::string'
				auto s2=std::string(“hellp”);//正确推导为std::string
	5.总结
		基本数据类型（如int）                             std:string
是否内置    是                                                    否
内存管理    固定大小，栈分配                          动态大小，堆分配
操作方法   仅支持运算符如（+，-）                提供成员方法（如：substr()）   
使用场景    存储简单值                                    处理文本或复杂字符序列  

float与double在开发中不用于运算，会有精度损失问题，例如：
float s=2.55f；
float b=1.23f;
float sb=s-b=1.3200001;这就造成精度损失，如果你的存款账户是这个会体验很差

变量不初始化不能直接使用
在同一个作用域中不能定义同名重名变量
在小作用域中能直接访问大作用域的变量
在大作用域中不能直接访问小作用域的变量

C++的初始化和赋值