1.1运算符分类:
	C++运算符按功能可分为以下几类：
1. ​**​算术运算符​**​  
    `+` `-` `*` `/` `%` `++` `--`
2. ​**​关系运算符​**​  
    `==` `!=` `>` `<` `>=` `<=`
3. ​**​逻辑运算符​**​  
    `&&` `||` `!`
4. ​**​位运算符​**​  
    `&` `|` `^` `~` `<<` `>>`
5. ​**​赋值运算符​**​  
    `=` `+=` `-=` `*=` `/=` `%=` 等
6. ​**​条件运算符​**​  
    `? :`
7. ​**​逗号运算符​**​  
    `,`
8. ​**​成员访问运算符​**​  
    `.` `->` `.*` `->*`
9. ​**​指针相关运算符​**​  
    `&`（取地址） `*`（解引用）
10. ​**​作用域解析运算符​**​  
    `::`
11. ​**​类型转换运算符​**​  
    `static_cast` `dynamic_cast` `const_cast` `reinterpret_cast`
12. ​**​内存管理运算符​**​  
    `new` `delete` `new[]` `delete[]`
1.2运算符优先级与结合性
	运算符优先级决定了运算顺序，结合性决定相同优先级运算符的执行方向
![[运算符优先级.png]]
1.3表达式基础：由运算符、操作数、括号组成。最终产生一个值
	示例 int a=5,b=3;
		int c=(a+b)*2;
	左值与右值，左值：出现在赋值左侧（有明确内存地址）
				右值：出现在赋值右侧（临时值）
			例如：	int x= 10;
				x = x+5;
1.4关键运算符解析 
	算术运算符
		/:整数除法会截断小数位
		%:操作数必须为整数
		++/--:前置（先增减后使用） 后置（先使用后增减）
		例如：int a=5; 
			int b=a++//b=5,a=6;
			int c=++a//a=7,c=7;
	关系与逻辑运算符
		返回bool类型（true或false）
		逻辑运算符支持短路求值
		if(x！=0&&/10/x>1)
	位运算符
		直接操作二进制位，适用于整数类型
		unsigned char flag=0b00110100;
		flag = flag & ~0b001010000;	
		按位与 &,按位或 |，按位异或 ^,按位取反~，移位(有符号与无符号的左移和右移)
	1.41按位与 &
		3&5即将二进制3和5进行匹配，有0为0，其他不变（两个1还是1）
	1.4.2按位或 |
		3 | 5也是二进制匹配，规则是，有1为1，其他不变（两个0还是0）
	1.4.3按位异或 ^
		一样是二进制匹配，规则是，相同为0，不同为1
	1.4.4按位取反 ~
			是一个单目运算符，对一个二进制数的每一位取反，<mark style="background-color: #1EFF00; color: black">十进制数 → 原码 → 补码 → 按位取反 → 取反后的补码 → 原码 → 十进制结果</mark>，<mark style="background-color: #fff88f; color: black">对补码求原码再次求反加1即可</mark>。
		1. **​通用公式​**​  
		    按位取反的结果可通过公式直接计算：  
			    ​**​~x = -(x + 1)​**​  
			    示例：~5 = -6，~(-5) = 4
		2. ​**​零的特殊性​**​  
		    零的按位取反结果为全1补码（如`11111111`），需转原码后得到-1（有符号整型
	1.4.5移位
		c++和Java的移位有区别，c++分有符号和无符号的左移和右移而java只要右移分有符号和无符号，但是左移其实都是逻辑位移（低位补0，高位溢出丢弃）
		右移
			 - ​**​有符号数​**​：采用​**​算术右移​**​，高位补符号位（如`-8 >> 1`结果为-4）
		    - ​**​无符号数​**​：采用​**​逻辑右移​**​，高位补0（如`unsigned int(128) >> 1`结果为64）
			主要差别还是
			![[java与c++的左移和右移的差异区别.png]]
			算术位移和逻辑位移均可快速计算
				左移 a * 2 * n
				右移 a / 2 * n（注意向下取整），如a>>5 得到的是5而非4
				区别是应用场景的不同，左移符号数注意是可能被覆盖的
				![[算术位移与逻辑位移的具体区别.png]]
			溢出处理，即移位的数字超过了本身得到bit位，从而有两者报错处理，一种是依赖硬件取模32，再移位，例如8>>32还是0，一种是未定义行为，产生报错
			类型提升规则（c++移位特殊处）
				定义：在移位运算前，编译器会先对操作数执行​**​整数提升​**​：
						- 若操作数是比 `int` 小的整数类型（如 `char`、`short`），则会被提升为 `int` 或 `unsigned int`
						- 若操作数已经是 `int` 或更大类型（如 `long`），则无需提升。
						示例：short a=5;
							int b =a<<2;//a先提升为int,结果类型仍为int
				作用：**保证运算的位宽一致性​**​
					- 小类型（如 `char`）的位宽可能不足（仅8位），直接移位可能导致溢出或符号位错误。提升为 `int`（通常32位）后，移位操作在高位有足够空间，避免意外截断
					示例：char c = 0x80;        // 二进制 10000000（-128）
						int result = c << 1;  // 提升为 int（0xFFFFFF80），左移1位后为 0xFFFF0000（-32768）
					​**​统一符号处理​**​
					- 无符号类型提升后仍为无符号（如 `unsigned char` → `unsigned int`），有符号类型提升后保持符号（如 `char` → `int`）。这确保移位时符号扩展的正确性
					示例：signed char sc = -1;  // 二进制补码 11111111（-1）
					int sc_promoted = sc; // 提升为 int（0xFFFFFFFF，仍为-1）
					防止未定义行为
						移位位数必须​**​小于提升后类型的位宽​**​。例如，若左操作数提升为 `int`（32位），则移位位数必须 `<32`，否则行为未定义
						错误示例：
							int a = 1;
							int b = a << 33;  // 未定义行为（移位位数 ≥32）
			### **实际应用中的注意事项​**
				​**​避免符号位覆盖**和<mark style="background-color: #1EFF00; color: black">数值与符号不变性</mark>
					- 对有符号数左移时，若覆盖符号位（如 `0x40000000 << 1` 变为 `0x80000000`），结果可能变为负数或触发未定义行为建议优先使用无符号类型。	
					-示例：unsigned int u = 0x80000000;  // 明确无符号，左移安全
						u <<= 1;  // 结果为 0x00000000（溢出后截断）
				​**​跨平台兼容性**
					不同编译器对移位位数的处理可能不同（如是否自动取模）。应显式限制移位位数：
					示例:if (shift_amount < sizeof(a)*8) {
					    a <<= shift_amount;}
				**与赋值运算符结合时的隐式转换**
					若结果类型与赋值目标类型不同，可能触发隐式转换
					示例：
					unsigned char uc = 0xFF;
					uc = uc << 4;  // 提升为 int，左移后赋值回 uc（截断为 0xF0）
	1.4.6 sizeof运算符
		语法形式：sizeof(类型名) 或 sizeof(表达式)，运算结果值为“类型名”所指定的类型或“表达式”的结果类型所占的字节数，在这个过程中并不对括号中的表达式本身求值
	1.4.7 赋值运算符
		复合赋值运算符如（+=）效率通常更高
		a +=5;//等价于a = a+5
		a *=b + 3;等价于a =a *(b+3)
	1.4.8 条件运算符
		int max =(a>b)？a:b;
	1.4.9 逗号运算符
		按顺序执行表达式，返回最后一个表达式的值
		int x=(a=3,b=2,a+b); //x=5
	1.5.0类型转换运算符
		优先使用c++风格转换如（static_cast）而非c风格转换
		double d=3.14;
		int i= static_cast<int>(d); // i=3
	1.5.1new和delete
		动态内存管理需配对使用
		int* arr=new int[10];
		delete[] arr;
	常见问题与注意事项
	2. ​**​优先级混淆​**​  
	    错误示例：`if (a & b == 0)` → 实际为 `a & (b == 0)`，应改为 `(a & b) == 0`。
	3. ​**​自增/自减副作用​**​  
	    避免在同一个表达式中多次修改同一变量：  
	    `int i = 0; int j = i++ + i++; // 未定义行为`
	4. ​**​整数除法陷阱​**​  
	    `5 / 2` 结果为 `2`，若需浮点结果，需转换类型：`5.0 / 2`。
	5. ​**​短路求值应用​**​  （例如a && b，如果a就是false那么b就不再计算）
	    利用 `&&` 和 `||` 避免无效操作：  
	    `if (ptr != nullptr && ptr->isValid()) { ... }`
	6. ​**​显式类型转换​**​  
	    减少隐式转换，避免精度丢失或意外行为
总结
- 掌握运算符优先级与结合性，必要时用括号明确意图。
- 注意操作数的类型转换，避免意外结果。
- 谨慎处理带有副作用的运算符（如 `++`、`--`）。
- 优先使用C++风格类型转换，增强代码安全性