OOP即Object Oriented Programming直译为“面向对象编程”（目标重用代码和抽象通用概念即组件的复用和扩展）==面向对象的核心：用类表示现实中的实体==
	oop设计原则：SOLID+C
		S-Single Responsibility Principle
			单一职责原则：
				一个类有且仅有一个引起它变化的原因，==一个类只负责一件事==，并且要把这件事做好，不写万能类，因为**问题：​**​ 这个类有无数个需要修改的原因：砖块管理规则变化、工资计算政策调整、支付方式升级、报表格式更改... 任何微小变动都可能影响整个类，导致牵一发而动全身。
		O-Open/Closed Principle
			开闭原则：
				核心思想：
					软件实体（类、模块、函数）应该对扩展开放，对修改关闭。
					==**加功能可以，改代码不行。要像乐高，能随意拼装，而不是改零件**==
				**搬砖例子​**​：
					要新增一个“按绩效计算工资”的功能，应该通过==继承== `SalaryCalculator`或实现新接口来​**​扩展​**​，而不是直接修改原有的 `calculate`方法。
				代码示例：
					![[Pasted image 20250908000324.png]]
		L-liskov Subsitution Principle（体现了面向对象编程的继承特点）
			里氏替换原则：
				核心思想：（不改变对象状态，不破坏语义（LSP本质是关于行为子类型化的规范，而行为不仅体现在异常和状态变更，还包括：方法返回值是否满足父类契约（比如返回值范围）、是否引入父类没有的副作用、对参数对象的修改是否符合预期（**需父类契约明确授权​**）等），不新增异常）
					子类必须能够替换掉它们的父类，而不改变程序的正确性
					==**说好是干电池，就不能是充电电池。说能替代，就不能拉胯，黄金法则：写子类时，假装自己是父类--调用者把我当父类用时，会不会出问题**==
					![[Pasted image 20250908001712.png]]
					示例1：修改内部算法逻辑 （**​关键​**​：输入输出行为和父类完全一致，只是内部实现不同），满足条件：数据输出的返回要满足父类要求的类型范围但可以优化范围如缩小，且返回的语义不能变，不修改外部状态即：禁止新增副作用，抛出异常，注意优化原料（原料是指方法内部依赖的对象或服务要满足输入/输出类型是否匹配和是否引入新异常？和业务语义是否一致？（如面包还是食物））和算法优化是体现黑盒原则，其中“==原料升级”的本质是==：用相同接口（契约）但更优质/高效的实现，替换方法依赖的内部对象或服务，如图中子类是用连接池替换了父类中的数据库的连接方式![[Pasted image 20250908112308.png]]总结![[Pasted image 20250908112724.png]]
					算法优化则是输出优化（更快/更精确）对于结果不一样，只要是符合父类要求的类型范围内即数据结果的更精确就没问题![[Pasted image 20250908111719.png]]
						![[Pasted image 20250908001740.png]]
					示例2：返回更具体的类型（协变返回类型：协变返回类型（Covariant Return Type）是面向对象编程中一个​**​允许子类重写父类方法时，返回更具体子类型​**​的特性。它像“青出于蓝而胜于蓝”的编程体现——儿子可以比爹更优秀（返回更精确的类型），但绝不坑爹（仍满足父类契约）==体现的是面向对象的多态机制==![[Pasted image 20250909083911.png]]
					![[Pasted image 20250909084002.png]]
					==实现关键点==![[Pasted image 20250909084054.png]]
					==应用场景==：![[Pasted image 20250909084146.png]]
					示例：![[Pasted image 20250909084207.png]]
					![[Pasted image 20250909084300.png]]
					==总结：==![[Pasted image 20250909084320.png]]
					）（调用者按父类 `Bread`使用返回值时完全无感知）
						![[Pasted image 20250908001801.png]]
					示例3.抛出更具体的异常（**关键​**​：捕获父类异常的代码仍能正常工作）可以抛出父类原异常中更精准的异常但是不能抛出父类未实现的其他异常即新建其他异常
						![[Pasted image 20250908001829.png]]
					示例4.添加可选的后置操作（**关键​**​：核心支付功能未变，只是增加了==非侵入式扩展==（不抛异常且遵循
					==无感知原则==：**调用方应完全感知不到后置操作的存在**）![[Pasted image 20250909085534.png]]
					问题：未抛异常，但是篡改了对象状态（工人被解雇），违反了业务语义。）
					即在原来基础上的服务新增额外服务但是不能没有原来父类的服务
						![[Pasted image 20250908001924.png]]总结添加后置操作：![[Pasted image 20250909085657.png]]且![[Pasted image 20250909085741.png]]
					示例5.放宽前置条件（**关键​**​：父类允许的输入（如 `value=5`），子类也必须允许。）这是放宽操作不是添加新规则。这里体现了==里氏替换原则的核心如何在不破坏契约的前提下扩展功能==
						实现要满足的是:**子类必须是父类输入的“超集”​**​ —— 父类允许的必须全放行，自己还能额外放行一些禁区。(==对方法的参数的宽松==)![[Pasted image 20250909184128.png]]![[Pasted image 20250908001955.png]]同例：![[Pasted image 20250909184528.png]]这里可以发现不仅用到了前置条件的宽松同时也增加了后置操作count == 0时rest()，体现了多重原则协同作用的完美体现
					总结替换原则心法![[Pasted image 20250908094954.png]
		I-Liskov Substitution Priciple(接口隔离原则)
			核心思想：不应该强迫客户端（调用者）依赖于它们不使用的接口。即，多个专门的接口比一个庞大臃肿的接口要好
			**搬砖例子​**​：不应该设计一个包含 `carryBricks`, `calculateSalary`, `manageTeam`的“万能接口” `IWorker`。而应该拆分为 `ILaborer`（劳工）、`ICalculator`（计算者）、`IManager`（管理者）多个接口，让不同的类按需实现
			示例：![[Pasted image 20250909192352.png]]![[Pasted image 20250909192703.png]]![[Pasted image 20250909192718.png]]
			俗话：![[Pasted image 20250909192600.png]]
		D-Dependency Inversion Priciple(依赖倒置原则)（接口的多态机制）
		核心思想：
			1.高层模块不应依赖低层模块，二者都应依赖于抽象。
			2.抽象不应依赖于细节（ “抽象不依赖细节” = 接口方法不暴露实现细节），细节应依赖于抽象（ 实现类必须履行接口契约）
			总结（简单说：依赖抽象，而非具体实现）
			具体解析核心思想（高层模块定义和调用接口，底层实现接口）
			流程图解![[Pasted image 20250910090810.png]]
			通俗的讲![[Pasted image 20250910001241.png]]![[Pasted image 20250909193355.png]]
示例：
			![[Pasted image 20250910001959.png]]![[Pasted image 20250910002020.png]]![[Pasted image 20250910002138.png]]
			![[Pasted image 20250910002201.png]]
			完整代码
			![[Pasted image 20250910002334.png]]
			![[Pasted image 20250910002346.png]]
			![[Pasted image 20250910002456.png]]
			![[Pasted image 20250910002618.png]]
			解析：
				依赖倒置原则通过：
						总结：先定义接口（只声明做什么核心业务），再创建一个对象类通过接口声明对核心业务的依赖，再在此类中通过构造函数或其他方式注入依赖也就是接口的传递，再定义行为函数，调用接口实现对象要去做什么，在类外创建不同的具体接口实现类，也就是做不同的事，通过在主程序中创建实现类对象和业务类对象，业务类对象中的参数是实现类对象，实现了业务类对象可以通过扩展来完成要求做的事情而不是修改
					1.反转依赖方向：高层模块定义抽象，底层模块实现
					2.解耦具体实现：通过接口隔离变化，对扩展开发，对修改关闭（开闭原则的基石）
					3.提升灵活性，支持运行时 **运行时动态切换​**
					最终实现面向对象编程，让系统像乐高积木一样可插拔，这才是软件设计的艺术所在
					传统依赖的问题![[Pasted image 20250909194858.png]]
					而使用DIP有以下优势
					![[Pasted image 20250909195025.png]]![[Pasted image 20250909194359.png]]
						实现技术：（接口怎么传递的问题）核心思想：​**​不要自己创建依赖，让别人传给你**
						依赖注入（DI）通过构造函数、Setter或接口注入依赖
						![[Pasted image 20250909194716.png]]
						1.构造函数注入（最推荐）可以用lambda表达式增强实现
						![[Pasted image 20250910003011.png]]![[Pasted image 20250910015317.png]]
						完整构造过程
						![[Pasted image 20250910015239.png]]
						2.Setter方法注入 （应用场景：游戏角色换装备）
						![[Pasted image 20250910105605.png]]
						游戏角色换装备示例![[Pasted image 20250910111418.png]]
						Setter注入注意事项：
						![[Pasted image 20250910111645.png]]
						![[Pasted image 20250910111700.png]]
						示例代码编写步骤![[Pasted image 20250910105713.png]]
						和![[Pasted image 20250910105727.png]]![[Pasted image 20250910105817.png]]解析：new 返回对象引用 ： new `铁锹工具()`是一个表达式，它执行后直接返回​**​新对象的引用​**​（内存地址）
						方法参数接收引用 `设置工具()`方法接收的是 `搬砖工具`类型参数，而 `铁锹工具`实现了该接口，所以可以传入
				分布 vs 合并的使用场景 合并写法是​**​组合模式​**​的体现
				 `new 铁锹工具()`创建​**​部分​**​（Part）`
				.设置工具()`组装到​**​整体​**​（Whole）
						它强调了​**​创建与使用的分离​**​，即使创建动作在调用时发生		合并适用于对象的一次性使用且无添加额外配置
						![[Pasted image 20250910110601.png]]构造函数注入与Setter注入的区别与如何选择
						![[Pasted image 20250910111233.png]]
						3.接口注入（较少用）：定义另一个注入接口声明依赖接收方法，被注入类实现接口，容器调用注入方法（依赖传递）
						![[Pasted image 20250910015549.png]]
						4.工厂模式（是创建型设计模式，解决了​**​对象创建逻辑复杂​**​的问题，将对象的创建和使用分离，简单说，工厂模式就是​**​专门负责生产对象的工厂​**​，你不需要自己`new`对象，而是告诉工厂"我要什么"，工厂就会给你对应的产品）
						传统创建对象的问题
						什么时候考虑工厂模式编码？当`new`关键字后面跟着复杂的条件判断或多步初始化时，就该考虑工厂模式了！
						![[Pasted image 20250911004844.png]]
						![[Pasted image 20250911004857.png]]
				工厂模式三大类型
						==1.静态工厂==（简单工厂） 核心思想：​**​一个工厂类负责创建所有类型的产品​**​，客户端通过参数指定所需产品类型
						![[Pasted image 20250911010503.png]]
						![[Pasted image 20250911010525.png]]
						![[Pasted image 20250911083423.png]]
						![[Pasted image 20250911010540.png]]
						![[Pasted image 20250911010902.png]]
						==2.工厂方法模式== 核心思想每个具体产品对应一个具体工厂。通过工厂子类决定创建哪种产品 
						实现方式：额外定义了一个创建对象的接口，但让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类
					两种实现的主流方式：
						1.抽象类方法
							总结：
							客户端代码（Client）只依赖于抽象工厂（VehicleFactory）和抽象产品（Vehicle），而不依赖于具体类
							代码示例
							![[Pasted image 20250911093656.png]]
							![[Pasted image 20250911085958.png]]![[Pasted image 20250911090007.png]]
							代码解析：
							1.抽象工厂类的作用：
								1.1`VehicleFactory`是一个抽象类，它定义了一个抽象方法`createVehicle()`，这个方法由子类实现以创建具体的产品
								1.2它还可以包含一些通用的逻辑（比如`deliverVehicle()`方法），这些逻辑可以操作由工厂方法创建的产品
							2.主程序中的调用
								2.1VehicleFactory factory = new CarFactory(); // 创建具体工厂
								2.2Vehicle vehicle = factory.createVehicle(); // 调用工厂方法创建产品
								2.3vehicle.drive(); // 调用产品的方法
							3.为什么主程序可以这样写
								3.1`factory`是`VehicleFactory`类型，但实际指向的是`CarFactory`对象
								3.2当调用`factory.createVehicle()`时，由于多态性，实际调用的是`CarFactory`中的`createVehicle()`方法，返回一个`Car`对象（因为`Car`实现了`Vehicle`接口，所以可以赋值给`Vehicle`类型的变量`vehicle`
								3.3然后调用`vehicle.drive()`，同样由于多态性，实际调用的是`Car`类的`drive()`方法
							4.执行过程详解
								![[Pasted image 20250911093834.png]]
									![[Pasted image 20250911093857.png]]
						2.纯接口方法（主流）==这种设计是面向对象编程中​**针对接口编程，而非实现编程**原则的经典体现，也是工厂方法模式强大灵活性的基础==
							具体工厂类创建的是实现了业务接口的具体产品对象。因此，当我们通过工厂创建产品后，就可以调用业务接口中定义的方法（返回类型是业务接口类型）
							执行过程详解：
							1.定义产品接口（业务接口）
							![[Pasted image 20250911095153.png]]
							2.实现具体产品
							![[Pasted image 20250911095212.png]]
							3.定义工厂接口
							![[Pasted image 20250911095232.png]]
							4.实现具体工厂
							![[Pasted image 20250911095247.png]]
							主程序调用
							![[Pasted image 20250911095312.png]]
					抽象类方式和纯接口方式的调用对比
						![[Pasted image 20250911100424.png]]
					代码结构对比
						![[Pasted image 20250911100506.png]]
						![[Pasted image 20250911100515.png]]
				==抽象工厂模式==  产品接口（定义业务功能）与工厂接口（定义创建产品的方法 ） 多了一个工厂选择器 （和构造函数注入相比他更解耦，只依赖抽象接口，构造函数注入直接依赖具体工具类）
						核心思想：抽象工厂模式提供一个​**​创建一系列相关或相互依赖对象​**​的接口，而无需指定它们的具体类
						![[Pasted image 20250911103908.png]]
						过程步骤详解
						![[Pasted image 20250911115215.png]]
						![[Pasted image 20250911115223.png]]
						![[Pasted image 20250911115245.png]]
						![[Pasted image 20250911103208.png]]
						总结经验就是：（接口继承的设计模式）
						定义一个大组件接口，小组件继承此大组件，再去构造具体实现类，这样的好处是可以统一处理所有的组件，功能或者说组件扩展只需扩展接口
						5.字段注入：字段注入（Field Injection）是一种依赖注入方式，它直接在类的字段上使用注解（如Spring的`@Autowired`）来自动注入依赖 ==字段注入的本质==：==**将具体实现类的实例直接存储到高层模块中声明为接口类型的引用字段中或者说是将具体实现类的实例内存地址，存储到高层模块的接口类型引用变量中@Bean注解用于显式声明一个Bean，并将其添加到Spring的应用上下文中。它通常用在配置类（被`@Configuration`注解标记的类）中，用于定义那些无法通过组件扫描（如`@Component`//spring会扫描并创建此bean、`@Service`标记为spring管理的服务等）自动注册的Bean
						**在配置类中使用`@Bean`本质上就是「集中式创建和组装高层模块」的过程**
						@Autowired​**​自动注入已定义的Bean​**，使用在字段、构造函数或方法上
						![[Pasted image 20250910112428.png]]
						![[Pasted image 20250910192017.png]]
						![[Pasted image 20250910192036.png]]
						![[Pasted image 20250910192108.png]]注意事项![[Pasted image 20250910192239.png]]字段注入的生命周期
						![[Pasted image 20250910192729.png]]
						自我总结：spring框架的字段注入编程
						定义业务接口（行为标准），创建具体实现类@Component（做事的人或者说做什么事情），创建服务类@Service，服务类中@Autowired使声明的接口类型数据​**​将具体实例绑定到接口引用​**​（`tool`字段指向`ShovelService`实例），以便服务类的行为函数可以不需要参数执行具体的实现类方法（通过默认无参构造函数创建实例）![[Pasted image 20250910192855.png]]
						![[Pasted image 20250910192855.png]]
						![[Pasted image 20250910112846.png]]
						问题：
							依赖隐藏（无法直视看到依赖）
							脱离框架无法初始化
							破坏封装性
						6.服务定位器模式
						注意事项以及误区![[Pasted image 20250909195119.png]]实际应用场景
						![[Pasted image 20250909195328.png]]
				==对依赖倒置原则的关键认知==
				![[Pasted image 20250910020536.png]]
				![[Pasted image 20250910020548.png]]![[Pasted image 20250910020621.png]]
		对象属性存储固有状态（如姓名）
		方法参数传递操作数据（如本次搬砖量） 这种设计保证对象的轻量化和方法的可重用性（同一个工人可多次搬不同数量的砖）
这是一个非常有难度的编程思想，要结合书籍学习
	![[Pasted image 20250907221238.png]]
	![[Pasted image 20250907221306.png]]
	![[Pasted image 20250907221320.png]]
	![[Pasted image 20250907221331.png]]
	![[Pasted image 20250907221343.png]]
		分工思维，它==强调的是数据==，设计与问题的本质特性相对应的数据格式，即“类”，而对象是根据类构造的特定数据结构，类描述基本特征，对象在此之上含有本质特征，即属性和行为，类规定了可使用哪些数据来表示对象以及可以对这些数据执行哪些操作，例如定义一个描述矩形的类，定义的数据部分包括顶点的位置、长和宽等，定义的操作包括移动，改变大小，旋转等，该对象保存了描述矩形的所有数据值，因此可以修改类方法来修改该矩形，即由低级组织（类）到高级组织（程序）的自下向上的编程，包含封装（隐藏内部类的细节只暴露接口保证类的安全和易用），多态（为运算符和函数创建多个定义），继承（旧类派生新类）的特点
	示例 搬砖
		![[Pasted image 20250907202137.png]]
		![[Pasted image 20250907202154.png]]
		![[Pasted image 20250907202225.png]]
		完整示例
		![[Pasted image 20250907213803.png]]
		![[Pasted image 20250907213824.png]]
		![[Pasted image 20250908004033.png]]
		![[Pasted image 20250908004049.png]]
		![[Pasted image 20250908004200.png]]
		![[Pasted image 20250908004215.png]]
		 面向对象方法调用的细节解析
			 ![[Pasted image 20250907223608.png]]
				 **`bricksToCarry`是方法的参数（parameter）​**​，而不是类的属性（property），这意味着：
				1. 1.
			    ​**​它不由类内部存储​**​：不是 `Worker`类的成员变量（如 `name`）
				2. 2.
				​**​它由外部调用时传入​**​：每次调用方法时临时传入，调用结束后消失
				![[Pasted image 20250908002734.png]]
				**参数是局部变量​**​：只在方法执行期间存在
				**与对象属性分离​**​：即使多次调用，每次的 `bricksToCarry`都是独立的
			==** 为什么这样设计？（OOP的核心思想）**==
					 1. ​**​避免无效状态存储​**
						![[Pasted image 20250908002902.png]]
					2.符合现实逻辑
						![[Pasted image 20250908002952.png]]
					3.减少对象臃肿
						![[Pasted image 20250908003016.png]]
				参数与属性的区别：
					![[Pasted image 20250908003512.png]]
		面向对象编程的缺点：
			![[Pasted image 20250912005849.png]]
			2.过度复杂
			![[Pasted image 20250912005929.png]]
			![[Pasted image 20250912005944.png]]
			![[Pasted image 20250912010022.png]]
			![[Pasted image 20250912011108.png]]
			![[Pasted image 20250912011132.png]]
			![[Pasted image 20250912011151.png]]
			![[Pasted image 20250912011204.png]]
			![[Pasted image 20250912011217.png]]
			![[Pasted image 20250912011228.png]]
			![[Pasted image 20250912011240.png]]
			![[Pasted image 20250912014819.png]]
			![[Pasted image 20250912014841.png]]
			五、行业实践中的问题		
					过度设计常见
						![[Pasted image 20250912015050.png]]
						![[Pasted image 20250912015103.png]]
						现代解决方案
							1.混合编程范式
							2.响应式编程
							![[Pasted image 20250912015203.png]]	
POP即Procedure Oriented Programming直译为“面向过程编程”（目标让代码流程清晰易懂） ==面向过程编程的核心：以函数为中心组织代码，通过参数传递数据==
	流程思维 “面向过程 = 步骤函数 + 数据传递”，==强调算法==的过程性编程
	特点：自顶向下以及结构化编程通过控制结构限制语句形成一组易理解和维护的结构
	==实际编码时灵活选择或融合（如OOP架构中嵌入POP算法），才是高手之道==
	![[Pasted image 20250902101958.png]]
	以及理解为什么说它是强调算法的核心步骤
	![[Pasted image 20250907215541.png]]
	示例：搬砖
	![[Pasted image 20250907213610.png]]
	![[Pasted image 20250907213653.png]]
	![[Pasted image 20250907213703.png]]
oop和pop的区别：
	![[Pasted image 20250907213941.png]]
	![[Pasted image 20250907214002.png]]
![[Pasted image 20250907214028.png]]
	对比：
	![[Pasted image 20250907214148.png]]
	面向对象的优势：
	![[Pasted image 20250907214210.png]]
	![[Pasted image 20250907214219.png]]
	![[Pasted image 20250907214227.png]]![[Pasted image 20250907214219.png]]
AOP：面向切面编程（Aspect Oriented Programming）
	通过`预编译`和`运行期动态代理`实现程序功能的统一维护。AOP是OOP的延续，针对业务处理过程中的切面进行提取，关注处理过程中的**某个步骤**或**阶段**，以降低逻辑过程中各部分之间耦合度。
	​ 专注与实现自身业务功能，周边业务功能可动态加进来（如：用户验证、日志处理、等）
	**何时用AOP？​**
		当需要为​**​多个核心模块​**​添加​**​==重复性非业务逻辑​**​==（如日志、事务、权限）时，优先选择AOP。你的搬砖场景中，“工时统计”和“安全审计”正是典型用例！
		AOP（面向切面编程）与OOP（面向对象编程）并非替代关系，而是​**​横向扩展与纵向深化的互补​**​：OOP负责核心业务模块的纵向封装（如“打工人”类），而AOP解决​**​分散在多个模块中的横切关注点​**​（如日志、权限等），实现“非侵入式增强”
		![[Pasted image 20250811102639.png]]
		![[Pasted image 20250811102927.png]]
		![[Pasted image 20250811102942.png]]
		![[Pasted image 20250811103009.png]]
		![[Pasted image 20250811103028.png]]
		![[Pasted image 20250811104446.png]]
		![[Pasted image 20250811104550.png]]
		![[Pasted image 20250811104632.png]]
		![[Pasted image 20250811104712.png]]
==泛型编程== （generic）是c++支持的另一种编程模式，与oop的目标相同，即使重用代码和抽象通用概念的技术更简单，但oop强调编程的数据方面，而泛型编程强调独立于==特点数据类型==，它们的侧重点不同，oop是一个管理大型项目的工具，而泛型编程提供了执行常见任务（如对数据排序或合并链表）的工具
		泛型编程（Generic Programming）是一种编程范式，其核心目标是​**​编写独立于数据类型的代码​**​ 。它强调将算法从特定的数据类型中分离出来，使得一套算法能适用于多种数据类型
		
		在C++中，泛型编程主要通过​**​模板（Template）​**​ 来实现，
		为了直观理解泛型编程要解决的问题，请看下面这个表格，它对比了未使用泛型和使用泛型的情况
![[Pasted image 20250901022656.png]]
		再举一个例子：c++的数据表示有多种类型——整数，小数，字符，字符串，用户定义的、由多种类型组成的复合结构，例如要对不同类型的数据进行排序，通常必须为每种类型创建一个排序函数，而泛型编程需要对语言进行扩展，以便可以只编写一个泛型(即不是特点类型的)函数，并将其用于各种实际类型。从c++模板提供了完成这种任务的机制
	什么是c++的模板？
			模板是C++实现泛型编程的利器，它就像一个​**​蓝图​**​或​**​模具​**​
	。编译器会根据这个蓝图，在你实际使用时填入具体的类型，“铸造”出真正可用的代码（这个过程称为​**​实例化​**​）
	模板主要分为两类：​**​函数模板（Function Template）​**​ 和​**​类模板（Class Template）**
			#### 1. 函数模板 (Function Template)
			 函数模板允许你定义一个通用的函数家族，其中的类型可以被参数化
			 ![[Pasted image 20250901024505.png]]
			 这里的 `T`是一个​**​类型形参​**​，它是一个占位符，代表任何一种数据类型。你可以使用任何有效的标识符，如 `T`、`Type`、`Elem`等